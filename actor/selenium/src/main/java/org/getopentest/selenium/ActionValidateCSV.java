package org.getopentest.selenium;

import org.getopentest.selenium.core.SeleniumTestAction;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.getopentest.logging.Logger;

public class ActionValidateCSV extends SeleniumTestAction{
	
	 private String csvFilePath = null;
	 private String csvHeader = null;
	 private String targetValue = null;
	 private String targetValueNext = null;
     private static final String CSV_SPLITTER = ",";
     
     @Override
     public void run( ) {
    	 super.run();
    	 this.getInputFile();
     }
	 private void getInputFile() {
		csvFilePath = this.readStringArgument("csvFilePath", null);
	    csvHeader = this.readStringArgument("csvHeader", null);
	    targetValue = this.readStringArgument("targetValue", null);
	    targetValueNext = this.readStringArgument("targetValueNext", null);
	    
		String line = null;
		boolean headerFound = false;
		boolean targetValue = false;	
		String header = null;		
		Integer headerPosition = null;
		StringBuffer sb = new StringBuffer("");
		try (BufferedReader br = new BufferedReader(new FileReader(csvFilePath))) {			
			 while ((line = br.readLine()) != null) {
			   if(line.contains(csvHeader)) {
					headerFound = true;
					header = line;								  
				}			   
			   if(headerFound) {
					headerPosition = this.getHeaderColumn(header);				
					sb.append(line);			
					sb.append(System.lineSeparator());					
					if( null != headerPosition) {
						if(this.processFile(headerPosition, sb)) {
							if(null != targetValueNext && !targetValueNext.equalsIgnoreCase("null")){
								if(processFileNextValueNew(headerPosition, sb, targetValueNext)) {
									targetValue = true;
									break;
								}								
							}else{
									targetValue = true;
									break;
							}
						}					
					} else {
						  throw new RuntimeException(targetValue + " Not found in the column " + csvHeader);				            
					}
					 
				}	
			}
			
		} catch (IOException e) {
				e.printStackTrace();
	  }
		
	if(targetValue == false){
		throw new RuntimeException("Target value not found ==> " + targetValue);	
	}
  }	
	
	private Integer getHeaderColumn(String header) {
		Integer headerColumn = null;
		String[] arr = header.split(",");
		for(int  i=0; i< arr.length ;i++) {
			if(arr[i].equalsIgnoreCase(csvHeader)) {
				headerColumn = i;
			}
		}		
		return headerColumn;
	}
	private Integer getNextHeaderColumn(String header, String nextValue) {
		Integer headerColumn = null;
		String nextHeader = nextValue.split(":")[0];
		String[] arr = header.split(",");
		for(int  i=0; i< arr.length ;i++) {
			if(arr[i].equalsIgnoreCase(nextHeader)) {
				headerColumn = i;
			}
		}		
		return headerColumn;
	}
	private boolean processFile(int headerPosition, StringBuffer sb) {
		boolean foundElement = false;		
		String[] cols = null;		
		List<String> list = new ArrayList<String>();			
			String[] arr = sb.toString().split(System.lineSeparator());
			for(String line: arr) {
				  if(line.contains(CSV_SPLITTER)) {
					 cols = line.split(CSV_SPLITTER);
				     list.add(cols[headerPosition]);
				  }
			}				
			Collections.reverse(list);			
			if(list.contains(targetValue)) {
					 Logger.info("Target value found :::: "+ targetValue);
					 foundElement = true;
			}
		return foundElement;
	}
	private boolean processFileTargetValue(int headerPosition, StringBuffer sb, String targetVlaueNew) {
		boolean foundElement = false;		
			String[] arr = sb.toString().split(System.lineSeparator());
			Collections.reverse(Arrays.asList(arr));
			for(String line: arr) {
				if(line.contains(targetValue)){
					String pattern = "\\b"+targetVlaueNew+"\\b";
			         Pattern p=Pattern.compile(pattern);
			         Matcher m=p.matcher(line);
			         if(m.find()){
						foundElement = true;
						Logger.info("Target next value found :::: "+ targetVlaueNew);
						break;
			         }
				}
			}				
		return foundElement;
	}
	
	private boolean processFileNextValueNew(int headerPosition, StringBuffer sb, String targetNextVlaue) {
		String line = null;
		boolean headerFound = false;
		boolean targetValueF = false;	
		String header = null;		
		Integer headerPositionNew = null;
		String targetValue = null; 
		try (BufferedReader br = new BufferedReader(new FileReader(csvFilePath))) {			
			 while ((line = br.readLine()) != null) {
			   if(line.contains(csvHeader)) {
					headerFound = true;
					header = line;	
					if(headerFound) {
						   String[] arr = targetNextVlaue.split(";");
						   for(int  i=0; i< arr.length ;i++) {
							   headerPositionNew = getNextHeaderColumn(header,arr[i]);				
								sb.append(line);			
								sb.append(System.lineSeparator());					
								if( null != headerPositionNew) {
									if(processFile(headerPosition, sb)) {
										targetValue = arr[i].split(":")[1];
											if(processFileTargetValue(headerPositionNew, sb, targetValue)) {
												targetValueF = true;
//												break;
											} else {
												  throw new RuntimeException(targetValue + " Not found in the column " + csvHeader);				            
											}								
									}					
								} else {
									  throw new RuntimeException(targetValue + " Not found in the column " + csvHeader);				            
								}
							}
						}
				}			   
			}
		} catch (IOException e) {
				e.printStackTrace();
		}
		
		targetNextVlaue = null;
		
		return 	targetValueF;
	}
	
}
